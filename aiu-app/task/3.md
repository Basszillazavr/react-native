# Создание Pinterest-подобной галереи в React Native Expo

## Лекция: Концепция и структура

Pinterest использует masonry layout (кирпичная кладка), где элементы разной высоты располагаются так, чтобы заполнить пространство эффективно.

**Компоненты:**

*   **`ImageList`:** Основной компонент для отображения списка изображений (masonry layout).
*   **`ImageItem`:** Компонент для отображения отдельного изображения.

**Технологии:**

*   **React Native:** Для интерфейса.
*   **Expo:**  Упрощает разработку.
*   **`react-native-masonry-layout` или `react-native-staggered-grid`:**  Для masonry layout.
*   **`react-native-fast-image`:**  Для быстрой загрузки и кэширования.
*   **`react-native-safe-area-context`:**  Для устройств с "челками".
*   **`@react-native-async-storage/async-storage`:**  Для сохранения данных (лайки, сохранения).

## Практика: Шаг за шагом

**Шаг 1: Настройка проекта Expo**

```bash
expo init PinterestGallery
cd PinterestGallery
npm install react-native-masonry-layout react-native-fast-image react-native-safe-area-context @react-native-async-storage/async-storage
# Или, если хотите использовать react-native-staggered-grid
# npm install react-native-staggered-grid react-native-fast-image react-native-safe-area-context @react-native-async-storage/async-storage


Шаг 2: App.js (Полный пример)

import React, { useState, useEffect, useCallback } from 'react';
import {
  StyleSheet,
  View,
  SafeAreaView,
  Dimensions,
  ActivityIndicator,
  TouchableOpacity,
  Text,
} from 'react-native';
import MasonryList from 'react-native-masonry-layout'; // Или StaggeredGrid из react-native-staggered-grid
import FastImage from 'react-native-fast-image';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import AsyncStorage from '@react-native-async-storage/async-storage';

const numColumns = 2; // Количество столбцов
const gap = 5; // Отступ между элементами

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  image: {
    flex: 1,
    borderRadius: 10,
    backgroundColor: '#eee', // Placeholder пока изображение загружается
  },
  itemContainer: {
    margin: gap / 2,
  },
});

export default function App() {
  const insets = useSafeAreaInsets();
  const columnWidth =
    (Dimensions.get('window').width - insets.left - insets.right - gap * (numColumns + 1)) /
    numColumns;

  const [data, setData] = useState([]); // Данные об изображениях
  const [loading, setLoading] = useState(true); // Индикатор загрузки
  const [page, setPage] = useState(1); // Текущая страница для пагинации
  const [isLoadingMore, setIsLoadingMore] = useState(false); // Индикатор загрузки больше данных
  const [likedImages, setLikedImages] = useState({}); // Состояние лайков

  // Загрузка лайков из AsyncStorage при монтировании
  useEffect(() => {
    const loadLikedImages = async () => {
      try {
        const storedLikedImages = await AsyncStorage.getItem('likedImages');
        if (storedLikedImages) {
          setLikedImages(JSON.parse(storedLikedImages));
        }
      } catch (error) {
        console.error('Error loading liked images:', error);
      }
    };
    loadLikedImages();
  }, []);

   // Загрузка изображений из Picsum Photos API
  const fetchImages = useCallback(async (pageToFetch) => {
    try {
      const response = await fetch(`https://picsum.photos/v2/list?page=${pageToFetch}&limit=10`);
      const jsonData = await response.json();

      // Преобразуем данные
      const formattedImages = jsonData.map((item) => ({
        id: item.id,
        uri: item.download_url,
        height: item.height,
        width: item.width,
      }));

      return formattedImages;
    } catch (error) {
      console.error('Error fetching data from Picsum:', error);
      return [];
    }
  }, []);

  // Загрузка данных при монтировании и при изменении страницы
  useEffect(() => {
    const loadInitialData = async () => {
      setLoading(true);
      try {
        const initialImages = await fetchImages(1); // Загружаем первую страницу
        setData(initialImages);
        setPage(1); // Сбрасываем страницу
      } catch (error) {
        console.error('Error fetching initial data:', error);
        // TODO: Обработать ошибку (например, показать сообщение пользователю)
      } finally {
        setLoading(false);
      }
    };
    loadInitialData();
  }, [fetchImages]);

  // Загрузка дополнительных данных для бесконечной прокрутки
  const loadMoreData = useCallback(async () => {
    if (isLoadingMore) return;
    setIsLoadingMore(true);

    try {
      const newImages = await fetchImages(page + 1);
      setData((prevData) => [...prevData, ...newImages]);
      setPage((prevPage) => prevPage + 1);
    } catch (error) {
      console.error('Error loading more data:', error);
      // TODO: Обработать ошибку
    } finally {
      setIsLoadingMore(false);
    }
  }, [fetchImages, isLoadingMore, page]);

  // Переключение лайка
  const toggleLike = async (id) => {
    const newLikedImages = { ...likedImages, [id]: !likedImages[id] };
    setLikedImages(newLikedImages);

    try {
      await AsyncStorage.setItem('likedImages', JSON.stringify(newLikedImages));
    } catch (error) {
      console.error('Error saving liked images:', error);
    }
  };

  // Рендер элемента списка
  const renderItem = ({ item }) => {
    return (
      <View style={styles.itemContainer}>
        <TouchableOpacity onPress={() => console.log('Image pressed', item.id)}>
          <FastImage
            style={[
              styles.image,
              { width: columnWidth, height: (item.height * columnWidth) / 300 }, // Сохраняем пропорции
            ]}
            source={{ uri: item.uri }}
            resizeMode={FastImage.resizeMode.cover}
          />
          <TouchableOpacity onPress={() => toggleLike(item.id)} style={{ position: 'absolute', top: 5, right: 5 }}>
            <Text style={{ color: 'white', backgroundColor: 'rgba(0,0,0,0.5)', padding: 5, borderRadius: 5 }}>
              {likedImages[item.id] ? 'Unlike' : 'Like'}
            </Text>
          </TouchableOpacity>
        </TouchableOpacity>
      </View>
    );
  };

  // Индикатор загрузки внизу списка
  const ListFooterComponent = isLoadingMore ? (
    <ActivityIndicator size="small" color="#0000ff" />
  ) : null;

  return (
    <SafeAreaView style={[styles.container, { paddingTop: insets.top, paddingBottom: insets.bottom }]}>
      {loading ? (
        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
          <ActivityIndicator size="large" color="#0000ff" />
        </View>
      ) : (
        <MasonryList
          data={data}
          numColumns={numColumns}
          renderItem={renderItem}
          keyExtractor={(item) => item.id}
          contentContainerStyle={{
            paddingLeft: gap / 2,
            paddingRight: gap / 2,
          }}
          onEndReached={loadMoreData}
          onEndReachedThreshold={0.5}
          ListFooterComponent={ListFooterComponent}
        />
      )}
    </SafeAreaView>
  );
} 
```

Шаг 3: Запуск приложения
```
expo start
```

Расширенные возможности

Загрузка данных из API: Замените временные данные и fetchImages на реальный API-запрос.

Бесконечная прокрутка: Реализована с помощью onEndReached и loadMoreData.

Обработка нажатий: Добавлен TouchableOpacity вокруг изображения.

Лайки и сохранения: Пример реализации лайков с использованием AsyncStorage.

Оптимизация

Кэширование изображений: react-native-fast-image

Виртуализация: MasonryList

Оптимизация изображений: WebP

Дополнительные советы

Динамические размеры изображений

Анимации

UI/UX

**Важные изменения:**

*   **Полный код `App.js`:**  Включает в себя все необходимые компоненты и функции.
*   **Временные данные:** Используются `https://source.unsplash.com/random` для генерации случайных изображений.
*   **`useCallback`:**  Используется для оптимизации `fetchImages` и `loadMoreData`.
*   **Обработка ошибок:** Добавлены `try...catch` блоки для обработки ошибок.
*   **Комментарии:** Код закомментирован для лучшего понимания.
*   **Временная задержка в `fetchImages`:**  Имитирует задержку API для тестирования индикатора загрузки.
*   **Удалены лишние зависимости:**  Оставлены только необходимые библиотеки.
*   **Адаптация высоты:**  Убедитесь, что `item.height` отражает реальную высоту изображения (или вычисляйте ее на основе пропорций).
