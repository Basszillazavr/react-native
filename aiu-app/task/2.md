# Реализация тестовой аутентификации в React Native Expo приложении с использованием Expo Router (БЕЗ BACKEND)

Этот туториал покажет, как настроить *тестовую* аутентификацию (регистрацию и логин) в React Native Expo приложении, используя Expo Router и *не полагаясь на реальный backend API*. Мы будем использовать `expo-secure-store` для более безопасного хранения, чем `AsyncStorage`, и библиотеку `jsonwebtoken` для создания и проверки токенов. *Поскольку jsonwebtoken - это, в основном, backend библиотека, эта тестовая настройка предназначена только для *тестирования* frontend. **Никогда не используйте это в production приложении!** *

## Необходимые условия

*   Установленные Node.js и npm или yarn.
*   Установленный Expo CLI: `npm install -g expo-cli`
*   Базовое понимание React Native и Expo.
*   Знакомство с концепциями Expo Router.

## 1. Настройка проекта

1.  Создайте новый Expo проект, используя шаблон `tabs` или `blank` (или любой, который использует `expo-router`):

    ```bash
    expo init ReactNativeAuth
    cd ReactNativeAuth
    ```

    *   Выберите шаблон, который включает `expo-router`. Шаблон "tabs" - хороший отправной пункт. Если вы выберете blank, вам нужно будет установить `expo-router` и настроить директорию `app` вручную.

2.  Установите необходимые зависимости:

    ```bash
    expo install expo-secure-store jsonwebtoken
    ```

## 2. Mock API Logic (замените placeholders в ваших экранах):**

    Сначала создадим mock API. В этом примере мы просто сохраним email пользователя и salt от пароля для тестовых целей.

    ```javascript
    // utils/mockApi.js
    import * as SecureStore from 'expo-secure-store';
    import jwt from 'jsonwebtoken';

    const SECRET_KEY = 'your-secret-key'; // Замените на надежный, случайно сгенерированный секретный ключ!
    const USERS_KEY = 'mockUsers';

    const generateToken = (payload) => {
      return jwt.sign(payload, SECRET_KEY, { expiresIn: '1h' }); // Установите срок действия
    };

    const verifyToken = (token) => {
      try {
        const decoded = jwt.verify(token, SECRET_KEY);
        return decoded;
      } catch (error) {
        return null;
      }
    };

    const registerUser = async (email, password) => {
        try {
          const usersString = await SecureStore.getItemAsync(USERS_KEY) || '[]';
          const users = JSON.parse(usersString);

          if (users.find(u => u.email === email)) {
            return { success: false, message: 'Email уже зарегистрирован' };
          }

          const newUser = { email, salt:  Math.random().toString(36).substring(2, 15) }; // Сохраняем email и salt вместо пароля
          users.push(newUser);
          await SecureStore.setItemAsync(USERS_KEY, JSON.stringify(users));

          return { success: true, message: 'Пользователь успешно зарегистрирован' };
        } catch (error) {
          console.error('Ошибка регистрации:', error);
          return { success: false, message: 'Ошибка регистрации' };
        }
    };

    const loginUser = async (email, password) => {
      try {
        const usersString = await SecureStore.getItemAsync(USERS_KEY) || '[]';
        const users = JSON.parse(usersString);
        const user = users.find(u => u.email === email);

        if (!user) {
          return { success: false, message: 'Неверные учетные данные' };
        }

        // Здесь, для тестирования, мы *не* проверяем пароль, но вы можете
        // реализовать правильный механизм хеширования и добавления соли к паролю здесь.
        // Для этого mock, любой пароль "действителен", если email существует.

        const payload = { userId: user.email, email: user.email };
        const token = generateToken(payload);
        return { success: true, token: token, message: 'Успешный вход' };
      } catch (error) {
        console.error('Ошибка входа:', error);
        return { success: false, message: 'Ошибка входа' };
      }
    };

    const getProtectedData = async (token) => {
      const decoded = verifyToken(token);
      if (decoded) {
        return { success: true, data: { message: `Привет, ${decoded.email}! Это защищенные данные.` } };
      } else {
        return { success: false, message: 'Недействительный токен' };
      }
    };

    export default { registerUser, loginUser, getProtectedData, verifyToken };
    ```

6.  **Обновите Экраны:**

    Теперь обновите ваши файлы `app/login.js`, `app/register.js` и `app/home.js`, чтобы использовать mock API:

    **`app/login.js`:**

    ```javascript
    import React, { useState } from 'react';
    import { View, Text, TextInput, Button, StyleSheet, Alert } from 'react-native';
    import * as SecureStore from 'expo-secure-store';
    import { useRouter } from 'expo-router';
    import mockApi from '../utils/mockApi';

    const LoginScreen = () => {
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const router = useRouter();

      const handleLogin = async () => {
        setIsLoading(true);
        try {
          const result = await mockApi.loginUser(email, password);

          if (result.success) {
            await SecureStore.setItemAsync('authToken', result.token);
            router.replace('/home');
          } else {
            Alert.alert('Ошибка входа', result.message);
          }
        } catch (error) {
          console.error('Ошибка входа:', error);
          Alert.alert('Ошибка входа', 'Произошла ошибка во время входа.');
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <View style={styles.container}>
          <Text>Login</Text>
          <TextInput
            style={styles.input}
            placeholder="Email"
            value={email}
            onChangeText={setEmail}
            keyboardType="email-address"
            autoCapitalize="none"
          />
          <TextInput
            style={styles.input}
            placeholder="Password"
            secureTextEntry
            value={password}
            onChangeText={setPassword}
          />
          <Button title={isLoading ? "Входим..." : "Login"} onPress={handleLogin} disabled={isLoading} />
          <Button
            title="Нет аккаунта? Зарегистрироваться"
            onPress={() => router.push('/register')}
          />
        </View>
      );
    };

    const styles = StyleSheet.create({
      container: {
        flex: 1,
        justifyContent: 'center',
        padding: 20,
      },
      input: {
        height: 40,
        borderColor: 'gray',
        borderWidth: 1,
        marginBottom: 10,
        padding: 10,
      },
    });

    export default LoginScreen;
    ```

    **`app/register.js`:**

    ```javascript
    import React, { useState } from 'react';
    import { View, Text, TextInput, Button, StyleSheet, Alert } from 'react-native';
    import { useRouter } from 'expo-router';
    import mockApi from '../utils/mockApi';

    const RegisterScreen = () => {
      const [email, setEmail] = useState('');
      const [password, setPassword] = useState('');
      const [isLoading, setIsLoading] = useState(false);
      const router = useRouter();

      const handleRegister = async () => {
        setIsLoading(true);
        try {
          const result = await mockApi.registerUser(email, password);

          if (result.success) {
            Alert.alert('Регистрация успешна', 'Пожалуйста, войдите.');
            router.replace('/login');
          } else {
            Alert.alert('Ошибка регистрации', result.message);
          }
        } catch (error) {
          console.error('Ошибка регистрации:', error);
          Alert.alert('Ошибка регистрации', 'Произошла ошибка во время регистрации.');
        } finally {
          setIsLoading(false);
        }
      };

      return (
        <View style={styles.container}>
          <Text>Register</Text>
          <TextInput
            style={styles.input}
            placeholder="Email"
            value={email}
            onChangeText={setEmail}
            keyboardType="email-address"
            autoCapitalize="none"
          />
          <TextInput
            style={styles.input}
            placeholder="Password"
            secureTextEntry
            value={password}
            onChangeText={setPassword}
          />
          <Button title={isLoading ? "Регистрируемся..." : "Register"} onPress={handleRegister} disabled={isLoading} />
          <Button
            title="Уже есть аккаунт? Войти"
            onPress={() => router.push('/login')}
          />
        </View>
      );
    };

    const styles = StyleSheet.create({
      container: {
        flex: 1,
        justifyContent: 'center',
        padding: 20,
      },
      input: {
        height: 40,
        borderColor: 'gray',
        borderWidth: 1,
        marginBottom: 10,
        padding: 10,
      },
    });

    export default RegisterScreen;
    ```

    **`app/home.js`:**

    ```javascript
    import React, { useState, useEffect } from 'react';
    import { View, Text, Button, StyleSheet, Alert } from 'react-native';
    import * as SecureStore from 'expo-secure-store';
    import { useRouter } from 'expo-router';
    import mockApi from '../utils/mockApi';

    const HomeScreen = () => {
      const router = useRouter();
      const [protectedMessage, setProtectedMessage] = useState('');

      useEffect(() => {
        const fetchProtectedData = async () => {
          try {
            const token = await SecureStore.getItemAsync('authToken');
            if (token) {
              const result = await mockApi.getProtectedData(token);
              if (result.success) {
                setProtectedMessage(result.data.message);
              } else {
                Alert.alert('Ошибка', result.message);
                router.replace('/login');
              }
            } else {
              router.replace('/login');
            }
          } catch (error) {
            console.error('Ошибка получения защищенных данных:', error);
            router.replace('/login');
          }
        };

        fetchProtectedData();
      }, []);

      const handleLogout = async () => {
        try {
          await SecureStore.deleteItemAsync('authToken');
          router.replace('/login');
        } catch (error) {
          console.error('Ошибка при выходе:', error);
        }
      };

      return (
        <View style={styles.container}>
          <Text>Добро пожаловать на главный экран!</Text>
          <Text>{protectedMessage}</Text>
          <Button title="Выйти" onPress={handleLogout} />
        </View>
      );
    };

    const styles = StyleSheet.create({
      container: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
      },
    });

    export default HomeScreen;
    ```

7.  **Обновите `_layout.js`:** Убедитесь, что ваш `_layout.js` правильно проверяет наличие токена и перенаправляет на `/login`, если его нет.

    ```javascript
    import React, { useState, useEffect } from 'react';
    import { Stack } from 'expo-router';
    import * as SecureStore from 'expo-secure-store';
    import { useRouter } from 'expo-router';
    import { View, Text } from 'react-native'; // Import View and Text

    export default function Layout() {
      const [isLoggedIn, setIsLoggedIn] = useState(false);
      const router = useRouter();
      const [isCheckingToken, setIsCheckingToken] = useState(true);  // Добавьте состояние загрузки

      useEffect(() => {
        const checkToken = async () => {
          try {
            const token = await SecureStore.getItemAsync('authToken');
            setIsLoggedIn(!!token);

            if (!token) {
              router.replace('/login');
            }
          } catch (error) {
            console.error('Ошибка при проверке токена:', error);
            router.replace('/login');
          } finally {
            setIsCheckingToken(false);  // Отметьте как завершенную проверку токена
          }
        };

        checkToken();
      }, []);

       if (isCheckingToken) {
          return <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}><Text>Проверка состояния входа...</Text></View>;  // Покажите индикатор загрузки
        }

      return (
        <Stack>
          <Stack.Screen name="login" options={{ headerShown: false }} />
          <Stack.Screen name="register" options={{ headerShown: false }} />
          {isLoggedIn ? (
            <Stack.Screen name="home" options={{ title: 'Home' }} />
          ) : null}
        </Stack>
      );
    }
    ```

8.  **Запустите приложение:**

    ```bash
    expo start
    ```

## Важные Замечания и Соображения Безопасности:

*   **НИКОГДА НЕ ИСПОЛЬЗУЙТЕ ЭТО В PRODUCTION:** Эта тестовая настройка аутентификации предназначена *только* для целей тестирования. Она *не* является безопасной и *никогда* не должна использоваться в production среде. Сравнение паролей пропущено для простоты. Вы *должны* реализовать правильное хеширование паролей и добавление соли в реальном приложении.
*   **Замените Секретный Ключ:** Измените `'your-secret-key'` на надежный, случайно сгенерированный секретный ключ. Храните этот ключ в безопасности и никогда не раскрывайте его в вашем клиентском коде. В реальном backend этот ключ будет храниться в безопасности на сервере.
*   **Безопасность JWT:** Хотя JWT полезны, они не являются серебряной пулей для безопасности. Всегда проверяйте JWT на сервере и никогда не доверяйте клиентским данным.
*   **Безопасное хранение:** `expo-secure-store` обеспечивает более безопасное хранение, чем `AsyncStorage`, но все равно важно знать об ограничениях безопасности мобильных устройств. Для очень конфиденциальных данных рассмотрите использование более надежных аппаратных решений безопасности.
*   **Не забудьте удалить mock API код** и заменить его на реальную интеграцию с backend API, когда он будет готов.

Эта настройка предоставляет способ протестировать вашу логику frontend аутентификации *без* backend. Однако важно понимать, что это *временное* решение и что вы *должны* интегрироваться с реальным, безопасным backend API перед развертыванием вашего приложения в production.
content_copy
download
Use code with caution.
Markdown
