## Урок: Управление состоянием в React Native с Context API и `useReducer`

**Цель урока:** Понять и научиться применять Context API и хук `useReducer` для эффективного управления состоянием в React Native приложениях, особенно в случаях, когда состояние необходимо передавать между множеством компонентов без прокидывания пропсов через каждый уровень.

---

### Лекция: Управление состоянием в React Native с Context API и `useReducer`

**1. Введение в управление состоянием:**

* Краткое напоминание о проблеме управления состоянием в больших React Native приложениях.
* Недостатки прокидывания пропсов (`prop drilling`).
* Обзор различных подходов к управлению состоянием (Redux, Zustand, Recoil, Context API + `useReducer`).
* Фокус на Context API и `useReducer` как встроенных средствах React.

**2. Context API:**

* **Что такое Context API?**
    * Механизм React для передачи данных (состояния, функций) вниз по дереву компонентов без явной передачи пропсов на каждом уровне.
    * Идеально подходит для глобальных данных приложения, таких как тема, язык, информация о пользователе и т.д.
* **Основные компоненты Context API:**
    * `React.createContext(defaultValue)`: Создает объект контекста. `defaultValue` используется, если компонент-потребитель не находится внутри `Provider`.
    * `Context.Provider`: Компонент, который предоставляет значение контекста всем своим потомкам. Принимает проп `value`, который может быть любым JavaScript значением.
    * `Context.Consumer`: Компонент, который подписывается на изменения контекста. Использует render prop (функцию как дочерний элемент).
    * `useContext(Context)`: Хук, который позволяет функциональным компонентам подписываться на контекст. Возвращает текущее значение контекста.

* **Пример использования Context API (простой):**

    ```javascript
    import React, { createContext, useContext, useState } from 'react';

    // 1. Создаем контекст
    const ThemeContext = createContext('light'); // Значение по умолчанию

    // 2. Создаем Provider
    const ThemeProvider = ({ children }) => {
      const [theme, setTheme] = useState('light');

      const toggleTheme = () => {
        setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
      };

      return (
        <ThemeContext.Provider value={{ theme, toggleTheme }}>
          {children}
        </ThemeContext.Provider>
      );
    };

    // 3. Используем контекст в компоненте-потребителе (через useContext)
    const ThemedButton = () => {
      const { theme, toggleTheme } = useContext(ThemeContext);

      return (
        <button style={{ backgroundColor: theme === 'light' ? '#eee' : '#333', color: theme === 'light' ? '#333' : '#eee' }} onClick={toggleTheme}>
          Toggle Theme
        </button>
      );
    };

    const App = () => (
      <ThemeProvider>
        <ThemedButton />
      </ThemeProvider>
    );

    export default App;
    ```

**3. `useReducer` Hook:**

* **Что такое `useReducer`?**
    * Альтернатива `useState` для управления более сложной логикой состояния.
    * Вдохновлен Redux и паттерном "reducer".
    * Позволяет централизовать логику обновления состояния в отдельной функции (reducer).
* **Основные элементы `useReducer`:**
    * `reducer(state, action)`: Чистая функция, которая принимает текущее состояние и объект действия (action) и возвращает новое состояние.
    * `dispatch(action)`: Функция, которая используется для отправки действия в reducer.
    * `initialState`: Начальное значение состояния.
    * `useReducer(reducer, initialState)`: Хук, который возвращает текущее состояние и функцию `dispatch`.

* **Пример использования `useReducer` (простой счетчик):**

    ```javascript
    import React, { useReducer } from 'react';

    // 1. Определяем reducer
    const counterReducer = (state, action) => {
      switch (action.type) {
        case 'increment':
          return { count: state.count + 1 };
        case 'decrement':
          return { count: state.count - 1 };
        case 'reset':
          return { count: 0 };
        default:
          return state;
      }
    };

    // 2. Определяем начальное состояние
    const initialState = { count: 0 };

    const Counter = () => {
      // 3. Используем useReducer
      const [state, dispatch] = useReducer(counterReducer, initialState);

      return (
        <div>
          <p>Count: {state.count}</p>
          <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
          <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
          <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
        </div>
      );
    };

    export default Counter;
    ```

**4. Комбинирование Context API и `useReducer`:**

* **Зачем комбинировать?**
    * Context API обеспечивает способ передачи состояния вниз по дереву компонентов.
    * `useReducer` предоставляет структурированный способ управления этим состоянием, особенно когда обновления становятся сложными.
* **Паттерн использования:**
    1.  Создайте Context для хранения состояния и функции `dispatch`.
    2.  Внутри `Provider` используйте `useReducer` для управления состоянием.
    3.  Передайте текущее состояние и функцию `dispatch` в `value` провайдера.
    4.  Компоненты-потребители используют `useContext` для доступа к состоянию и `dispatch`.

* **Пример комбинирования (управление темой):**

    ```javascript
    import React, { createContext, useContext, useReducer } from 'react';

    // 1. Создаем контекст
    const ThemeContext = createContext();

    // 2. Определяем reducer
    const themeReducer = (state, action) => {
      switch (action.type) {
        case 'toggle':
          return { theme: state.theme === 'light' ? 'dark' : 'light' };
        default:
          return state;
      }
    };

    // 3. Определяем начальное состояние
    const initialThemeState = { theme: 'light' };

    // 4. Создаем Provider
    const ThemeProvider = ({ children }) => {
      const [state, dispatch] = useReducer(themeReducer, initialThemeState);

      return (
        <ThemeContext.Provider value={{ ...state, dispatch }}>
          {children}
        </ThemeContext.Provider>
      );
    };

    // 5. Создаем хук для удобного использования контекста
    const useTheme = () => useContext(ThemeContext);

    // 6. Используем контекст в компоненте-потребителе
    const ThemedButton = () => {
      const { theme, dispatch } = useTheme();

      return (
        <button style={{ backgroundColor: theme === 'light' ? '#eee' : '#333', color: theme === 'light' ? '#333' : '#eee' }} onClick={() => dispatch({ type: 'toggle' })}>
          Toggle Theme
        </button>
      );
    };

    const App = () => (
      <ThemeProvider>
        <ThemedButton />
      </ThemeProvider>
    );

    export default App;
    ```

**5. Когда использовать Context API и `useReducer`?**

* Context API:
    * Глобальные данные, которые нужны многим компонентам.
    * Простые случаи глобального состояния.
    * Управление темой, языком, аутентификацией.
* `useReducer`:
    * Сложная логика обновления состояния.
    * Состояние с несколькими взаимосвязанными подзначениями.
    * Предсказуемые обновления состояния на основе действий.
* Комбинация:
    * Глобальное состояние со сложной логикой обновления.
    * Централизованное управление состоянием, доступное по всему приложению.

**6. Преимущества и недостатки:**

* **Преимущества:**
    * Встроенные в React (нет необходимости в сторонних библиотеках).
    * Упрощает передачу состояния по сравнению с прокидыванием пропсов.
    * `useReducer` делает логику обновления состояния более организованной и предсказуемой.
* **Недостатки:**
    * Context API может привести к ненужным перерисовкам компонентов, если значение контекста часто меняется и многие компоненты его используют. (Можно оптимизировать с помощью мемоизации и разделения контекстов).
    * Для очень сложных глобальных состояний сторонние библиотеки, такие как Redux или Zustand, могут предложить более продвинутые возможности (мидлвары, селекторы, и т.д.).

**7. Заключение:**

Context API и хук `useReducer` являются мощными инструментами для управления состоянием в React Native. Их комбинация позволяет эффективно управлять сложным глобальным состоянием, делая код более чистым и поддерживаемым. Понимание этих концепций является важным шагом в разработке крупных React Native приложений.

---

### Практическое задание: Управление корзиной товаров с Context API и `useReducer`

**Цель:** Создать простое приложение для отображения списка товаров и управления корзиной с использованием Context API и `useReducer`.

**Структура проекта:**

shopping-cart-app/
├── App.js
├── components/
│   ├── ProductList.js
│   └── Cart.js
└── context/
└── CartContext.js


**Шаги:**

**1. `context/CartContext.js`:**

* Создайте `CartContext` с начальным значением `{ items: [], dispatch: () => {} }`.
* Создайте `CartReducer` функцию, которая будет обрабатывать следующие действия:
    * `ADD_ITEM`: Добавляет товар в корзину (payload: `item` - объект товара с `id`, `name`, `price`).
    * `REMOVE_ITEM`: Удаляет товар из корзины по ID (payload: `id` - ID товара).
    * `UPDATE_QUANTITY`: Обновляет количество товара в корзине (payload: `{ id, quantity }`).
* Создайте `CartProvider` компонент:
    * Используйте `useReducer` с `CartReducer` и начальным состоянием `{ items: [] }`.
    * Предоставьте объект `{ items: state.items, dispatch }` в качестве `value` для `CartContext.Provider`.
* Создайте пользовательский хук `useCart` для удобного доступа к контексту.

**2. `components/ProductList.js`:**

* Отобразите список доступных товаров (можно захардкодить массив объектов с `id`, `name`, `price`). Пример:
    ```javascript
    const products = [
      { id: 1, name: 'Product A', price: 10 },
      { id: 2, name: 'Product B', price: 20 },
      { id: 3, name: 'Product C', price: 15 },
    ];
    ```
* Для каждого товара добавьте кнопку "Добавить в корзину".
* При нажатии на кнопку, получите функцию `dispatch` из `useCart` и отправьте действие `ADD_ITEM` с информацией о товаре.

**3. `components/Cart.js`:**

* Получите список товаров в корзине (`items`) и функцию `dispatch` из `useCart`.
* Отобразите список товаров в корзине, включая название, цену и количество.
* Для каждого товара в корзине добавьте кнопки "Удалить" (отправляет действие `REMOVE_ITEM` с `id` товара) и "Изменить количество" (можно реализовать через input или кнопки "+" и "-", отправляющие действие `UPDATE_QUANTITY`).
* Отобразите общую стоимость товаров в корзине.

**4. `App.js`:**

* Импортируйте `CartProvider` и оберните им все приложение.
* Отобразите компоненты `ProductList` и `Cart`.

**Дополнительные задания (по желанию):**

* Реализуйте увеличение и уменьшение количества товара в корзине с помощью кнопок.
* Добавьте стилизацию для улучшения внешнего вида.
* Используйте `AsyncStorage` для сохранения состояния корзины между запусками приложения.

**Ресурсы:**

* Документация React: [https://react.dev/learn/managing-state](https://react.dev/learn/managing-state)
* Документация `useReducer`: [https://react.dev/reference/react/useReducer](https://react.dev/reference/react/useReducer)
* Документация Context API: [https://react.dev/reference/react/createContext](https://react.dev/reference/react/createContext)
* Примеры и туториалы в интернете по "React Native Context API useReducer".

**Ожидаемый результат:**

Приложение с двумя основными экранами: список товаров и корзина. Пользователь может добавлять товары в корзину, просматривать содержимое корзины, удалять товары и изменять их количество. Состояние корзины управляется глобально с помощью Context API и `useReducer`.
